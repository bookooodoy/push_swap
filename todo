- Finish parsing errors checking
	Check that numbers exist X
	Check that there is no duplicate number X
	Check that integers are within integer range X
	
- Finish operations coding operations on the stacks X
	Structure for push_swap (stack) X
	sa (swap a): Swap the first 2 elements at the top of stack a. X
	Do nothing if there is only one or no elements.
	sb (swap b): Swap the first 2 elements at the top of stack b. X
	Do nothing if there is only one or no elements.
	ss : sa and sb at the same time. X
	pa (push a): Take the first element at the top of b and put it at the top of a.
	Do nothing if b is empty. X
	pb (push b): Take the first element at the top of a and put it at the top of b.
	Do nothing if a is empty. X
	ra (rotate a): Shift up all elements of stack a by 1. X
	The first element becomes the last one.
	rb (rotate b): Shift up all elements of stack b by 1. X
	The first element becomes the last one.
	rr : ra and rb at the same time. X
	rra (reverse rotate a): Shift down all elements of stack a by 1. X
	The last element becomes the first one.
	rrb (reverse rotate b): Shift down all elements of stack b by 1. X
	The last element becomes the first one.
	rrr : rra and rrb at the same time X


// OPERATIONS
	- Initialize X
	- Pop X
	- Insert X
	- Swap X

- Fix tail and next() pointers (bad assignation) X
- Correctly import libft
- Optimize functions
- Fix leaks

- Implement push_swap turk algorithm logic

//TURK ALGORITHM LOGIC
1) Find the cheapest number
	- Cheapest number algorithm:
	 If the number we look is smallest or biggest (small & big fnc)
		That means we shift the largest number in stack_b on top:
		 Take median of stack_b
		 Take median of stack_a
		 If the numbers we want to shift are in the same median
		   Rotate b and until target is at the top (count)
		   Count to rotate or shift until number is at top
		   Count the push
		 If they are not in the same median
		   Count (in stack_b) if shifting (up/down) changes median in stack_a
		   If it does, rotate both until smallest/biggest is at top of stack b
		   If it doesn't, rotate stack_b until the number is at the top
		   Then rotate stack_a
		   Push
	 If the number is not smallest or biggest
		Find it's ideal position (above it's closest lower)
		  
	        Repeat the logic above
	RETURN THE COUNT; WHILE LOOP UNLESS COUNT == 1
2) Apply logic above to swap until stack_a size is 3
3) Sort stack_a (very simple cases)
4) Push back to A
5) Sort trailing number in A


